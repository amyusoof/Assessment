# .gitlab-ci.yml (Parent Pipeline)

# Define default image
default:
  image: alpine/git:latest # A lightweight image with git and often curl/bash

stages:
  - generate_list
  - generate_ci
  - trigger_child

# --- Stage 1: Generate a dynamic list of items ---
# This job simulates generating a list of microservices.
# In a real scenario, this could involve:
# - Listing directories: `ls -d services/*/ | sed 's/services\///;s/\///'`
# - Calling an API: `curl ... | jq ...`
# - Reading from a database, etc.
generate-microservice-list:
  stage: generate_list
  script:
    - echo "Generating dynamic list of microservices..."
    # Simulate generating a JSON array of objects
    # Each object represents a microservice with a name and a version
    - |
      cat <<EOF > microservices.json
      [
        { "name": "user-service", "version": "1.0.0" },
        { "name": "product-catalog-service", "version": "1.2.1" },
        { "name": "order-processing-service", "version": "2.0.0" }
      ]
      EOF
    - echo "Generated microservices.json:"
    - cat microservices.json
  artifacts:
    paths:
      - microservices.json # Make the generated JSON file available to subsequent jobs
    expire_in: 1 hour # Keep artifact for a short period

# --- Stage 2: Generate the child .gitlab-ci.yml based on the dynamic list ---
# This job reads the microservices.json and constructs the child CI file.
# We use `jq` to parse the JSON and format it into YAML for GitLab CI jobs.
generate-child-ci-config:
  stage: generate_ci
  image:
    name: "mikefarah/yq" # A great tool for YAML processing, similar to jq for JSON
    entrypoint: ["/usr/bin/env", "bash"] # Ensure bash is used for the script
  script:
    - echo "Generating child CI configuration..."
    # Ensure jq is installed if not using yq for full JSON processing
    # If using yq, it can also process JSON
    - apk add --no-cache jq # Install jq if not already present in the image
    - |
      # Start with the basic structure of the child CI file
      echo "build_microservice_template:" > child-pipeline.yml
      echo "  stage: build" >> child-pipeline.yml
      echo "  script:" >> child-pipeline.yml
      echo "    - echo \"Building \${MICROSERVICE_NAME} version \${MICROSERVICE_VERSION}\"" >> child-pipeline.yml
      echo "    - echo \"Running build commands for \${MICROSERVICE_NAME}...\"" >> child-pipeline.yml
      echo "    - sleep 5" >> child-pipeline.yml
      echo "    - echo \"Build completed for \${MICROSERVICE_NAME}\"" >> child-pipeline.yml
      echo "" >> child-pipeline.yml # Add a newline for separation

      # Now, iterate over the microservices.json using jq to create parallel jobs
      # This creates a 'build' job for each microservice, using the template
      # and setting specific variables for each instance.
      jq -c '.[]' microservices.json | while read i; do
        MICROSERVICE_NAME=$(echo "$i" | jq -r '.name')
        MICROSERVICE_VERSION=$(echo "$i" | jq -r '.version')
        JOB_NAME="build-${MICROSERVICE_NAME//-/_}" # Replace hyphens for valid job names

        echo "${JOB_NAME}:" >> child-pipeline.yml
        echo "  extends: build_microservice_template" >> child-pipeline.yml
        echo "  variables:" >> child-pipeline.yml
        echo "    MICROSERVICE_NAME: \"${MICROSERVICE_NAME}\"" >> child-pipeline.yml
        echo "    MICROSERVICE_VERSION: \"${MICROSERVICE_VERSION}\"" >> child-pipeline.yml
        echo "  # Optional: Add specific rules or tags for this dynamic job" >> child-pipeline.yml
        echo "  # rules:" >> child-pipeline.yml
        echo "  #   - if: \$CI_COMMIT_BRANCH == \$CI_DEFAULT_BRANCH" >> child-pipeline.yml
        echo "" >> child-pipeline.yml # Add a newline for separation
      done

    - echo "Generated child-pipeline.yml:"
    - cat child-pipeline.yml
  artifacts:
    paths:
      - child-pipeline.yml # Make the generated CI file available
    expire_in: 1 hour
  needs:
    - generate-microservice-list # Ensure this job runs after the list is generated

# --- Stage 3: Trigger the child pipeline ---
# This job triggers the dynamically generated child-pipeline.yml.
trigger-dynamic-pipeline:
  stage: trigger_child
  trigger:
    include:
      - artifact: child-pipeline.yml # Path to the generated CI file artifact
        job: generate-child-ci-config # The job that produced the artifact
    strategy: depend # Wait for the child pipeline to complete
  needs:
    - generate-child-ci-config # Ensure this job runs after the child CI config is generated
